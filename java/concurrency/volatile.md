## volatile的作用
volatile关键字的三重功效：
- 内存可见性
- 禁止重排序
- 64位写入的原子性

## 内存可见性
可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到。

CPU缓存会带来内存可见性问题。L1、L2、L3和主内存之间是同步的，由缓存一致性协议的保证。但是StoreBuffer、LoadBuffer和L1之间却是异步的。也就是说，往内存中写入一个变量，这个变量会保存在StoreBuffer里面，稍后才异步地写入L1中，同时同步写入主内存中。

**volatile保证可见性的原理：**

对volatile变量进行写操作时，编译器会在指令前加上Lock前缀。
- Lock前缀指令会引起处理器缓存回写到内存。
- 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。

**伪共享问题：**

CPU读写基本单元是缓存行，一般CPU的缓存行都是64字节。

伪共享是指当两个变量处于同一缓存行时，CPU读写变量A会导致变量B的值更新，从而破坏了变量B的缓存特性，也就是说变量B伪共享。

对于一个会被频繁读写的volatile变量，应当让它独占一个缓存行，避免伪共享问题，可以采用字节填充来实现：
- 将变量手动填充为64字节
- java8使用注解：@sun.misc.Contended


## 重排序
重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。重排序同样可能会造成多线程程序错误。

重排序分3种类型：
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

**volatile禁止重排序的原理：**

volatile禁止重排序的原理是插入内存屏障。

理论上，可以把CPU内存屏障分成四种：
- LoadLoad：禁止读和读的重排序
- StoreStore：禁止写和写的重排序
- LoadStore：禁止读和写的重排序
- StoreLoad：禁止写和读的重排序



## 原子性
原子性是指一个或者多个操作在 CPU 执行过程中不会被中断。一个线程的原子性操作结果对其它线程是确定的，看不到其中间状态。

